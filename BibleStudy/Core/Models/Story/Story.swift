import Foundation
import GRDB

// MARK: - Story Type
// Classification of biblical stories

enum StoryType: String, CaseIterable, Codable, Sendable {
    case narrative   // Full narratives (Genesis creation, Exodus)
    case character   // Character-focused (Life of David, Paul's Journey)
    case thematic    // Theme-based (Redemption Through Scripture)
    case parable     // Jesus's parables
    case prophecy    // Prophetic narratives

    var displayName: String {
        switch self {
        case .narrative: return "Narrative"
        case .character: return "Character"
        case .thematic: return "Thematic"
        case .parable: return "Parable"
        case .prophecy: return "Prophecy"
        }
    }

    var icon: String {
        switch self {
        case .narrative: return "book.pages"
        case .character: return "person.fill"
        case .thematic: return "sparkles"
        case .parable: return "leaf.fill"
        case .prophecy: return "eye.fill"
        }
    }

    var storyTypeDescription: String {
        switch self {
        case .narrative: return "Full biblical narratives spanning chapters or books"
        case .character: return "Stories centered on specific biblical figures"
        case .thematic: return "Stories organized around theological themes"
        case .parable: return "Jesus's parables and their teachings"
        case .prophecy: return "Prophetic narratives and their fulfillment"
        }
    }

    var color: String {
        switch self {
        case .narrative: return "AccentGold"
        case .character: return "AccentBlue"
        case .thematic: return "HighlightPurple"
        case .parable: return "HighlightGreen"
        case .prophecy: return "AccentRose"
        }
    }
}

// MARK: - Story Reading Level
// Controls vocabulary, length, and complexity

enum StoryReadingLevel: String, CaseIterable, Codable, Sendable {
    case child       // Ages 6-10: Simple vocabulary, shorter segments
    case teen        // Ages 11-17: More detail, some context
    case adult       // Full detail, historical context, theological depth

    var displayName: String {
        switch self {
        case .child: return "Child"
        case .teen: return "Teen"
        case .adult: return "Adult"
        }
    }

    var shortLabel: String {
        switch self {
        case .child: return "Kids"
        case .teen: return "Teen"
        case .adult: return "Adult"
        }
    }

    var levelDescription: String {
        switch self {
        case .child: return "Simple words and short segments for young readers (ages 6-10)"
        case .teen: return "Balanced detail with age-appropriate context (ages 11-17)"
        case .adult: return "Full detail with historical and theological depth"
        }
    }

    var icon: String {
        switch self {
        case .child: return "figure.child"
        case .teen: return "figure.wave"
        case .adult: return "figure.stand"
        }
    }
}

// MARK: - Generation Mode
// Tracks how the story was created

enum GenerationMode: String, Codable, Sendable {
    case prebuilt    // Bundled with app
    case ai          // Generated by AI on demand
}

// MARK: - Story
// Represents a biblical narrative with segments

struct Story: Identifiable, Hashable {
    let id: UUID
    let slug: String                    // Unique identifier: "creation", "exodus-plagues"
    let title: String                   // "The Creation Story"
    let subtitle: String?               // "Genesis 1-2"
    let description: String             // Brief overview
    let type: StoryType
    let readingLevel: StoryReadingLevel
    let isPrebuilt: Bool
    let verseAnchors: [VerseRange]      // Primary verse ranges covered
    let estimatedMinutes: Int           // Reading time estimate
    let createdAt: Date
    var updatedAt: Date

    // For user-generated stories
    let userId: UUID?
    let isPublic: Bool

    // Generation Provenance (for debugging, trust, future updates)
    let generationMode: GenerationMode
    let modelId: String?                // e.g., "gpt-4o"
    let promptVersion: Int              // For tracking prompt changes
    let schemaVersion: Int              // For migration compatibility
    let generatedAt: Date?
    let sourcePassageIds: [String]      // Canonical verse refs

    // Related data (loaded separately)
    var segments: [StorySegment] = []
    var characters: [StoryCharacter] = []

    // MARK: - Computed Properties

    var book: Book? {
        guard let firstAnchor = verseAnchors.first else { return nil }
        return Book.find(byId: firstAnchor.bookId)
    }

    var reference: String {
        guard !verseAnchors.isEmpty else { return "" }
        if verseAnchors.count == 1 {
            return verseAnchors[0].reference
        }
        // Multiple ranges - show abbreviated
        let first = verseAnchors[0]
        let last = verseAnchors[verseAnchors.count - 1]
        if first.bookId == last.bookId {
            return "\(first.book?.name ?? "") \(first.chapter)-\(last.chapter)"
        }
        return "\(first.book?.name ?? "") - \(last.book?.name ?? "")"
    }

    var segmentCount: Int {
        segments.count
    }

    // MARK: - Initializers

    init(
        id: UUID = UUID(),
        slug: String,
        title: String,
        subtitle: String? = nil,
        description: String,
        type: StoryType,
        readingLevel: StoryReadingLevel,
        isPrebuilt: Bool = false,
        verseAnchors: [VerseRange],
        estimatedMinutes: Int,
        createdAt: Date = Date(),
        updatedAt: Date = Date(),
        userId: UUID? = nil,
        isPublic: Bool = false,
        generationMode: GenerationMode = .prebuilt,
        modelId: String? = nil,
        promptVersion: Int = 1,
        schemaVersion: Int = 1,
        generatedAt: Date? = nil,
        sourcePassageIds: [String] = [],
        segments: [StorySegment] = [],
        characters: [StoryCharacter] = []
    ) {
        self.id = id
        self.slug = slug
        self.title = title
        self.subtitle = subtitle
        self.description = description
        self.type = type
        self.readingLevel = readingLevel
        self.isPrebuilt = isPrebuilt
        self.verseAnchors = verseAnchors
        self.estimatedMinutes = estimatedMinutes
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.userId = userId
        self.isPublic = isPublic
        self.generationMode = generationMode
        self.modelId = modelId
        self.promptVersion = promptVersion
        self.schemaVersion = schemaVersion
        self.generatedAt = generatedAt
        self.sourcePassageIds = sourcePassageIds
        self.segments = segments
        self.characters = characters
    }

    // MARK: - Hashable (exclude mutable arrays)
    func hash(into hasher: inout Hasher) {
        hasher.combine(id)
    }

    static func == (lhs: Story, rhs: Story) -> Bool {
        lhs.id == rhs.id
    }
}

// MARK: - GRDB Support
extension Story: FetchableRecord, PersistableRecord {
    nonisolated static var databaseTableName: String { "stories" }

    enum Columns: String, ColumnExpression {
        case id
        case slug
        case title
        case subtitle
        case description
        case type
        case readingLevel = "reading_level"
        case isPrebuilt = "is_prebuilt"
        case verseAnchors = "verse_anchors"
        case estimatedMinutes = "estimated_minutes"
        case createdAt = "created_at"
        case updatedAt = "updated_at"
        case userId = "user_id"
        case isPublic = "is_public"
        case generationMode = "generation_mode"
        case modelId = "model_id"
        case promptVersion = "prompt_version"
        case schemaVersion = "schema_version"
        case generatedAt = "generated_at"
        case sourcePassageIds = "source_passage_ids"
    }

    nonisolated init(row: Row) {
        id = row[Columns.id]
        slug = row[Columns.slug]
        title = row[Columns.title]
        subtitle = row[Columns.subtitle]
        description = row[Columns.description]
        type = StoryType(rawValue: row[Columns.type]) ?? .narrative
        readingLevel = StoryReadingLevel(rawValue: row[Columns.readingLevel]) ?? .adult
        isPrebuilt = row[Columns.isPrebuilt]
        estimatedMinutes = row[Columns.estimatedMinutes]
        createdAt = row[Columns.createdAt]
        updatedAt = row[Columns.updatedAt]
        userId = row[Columns.userId]
        isPublic = row[Columns.isPublic]
        generationMode = GenerationMode(rawValue: row[Columns.generationMode]) ?? .prebuilt
        modelId = row[Columns.modelId]
        promptVersion = row[Columns.promptVersion]
        schemaVersion = row[Columns.schemaVersion]
        generatedAt = row[Columns.generatedAt]

        // Decode JSON arrays using nonisolated helpers
        if let anchorsJSON: String = row[Columns.verseAnchors] {
            verseAnchors = VerseRange.arrayFromJSON(anchorsJSON) ?? []
        } else {
            verseAnchors = []
        }

        if let passagesJSON: String = row[Columns.sourcePassageIds],
           let data = passagesJSON.data(using: .utf8),
           let decoded = try? JSONDecoder().decode([String].self, from: data) {
            sourcePassageIds = decoded
        } else {
            sourcePassageIds = []
        }

        // Segments and characters loaded separately
        segments = []
        characters = []
    }

    nonisolated func encode(to container: inout PersistenceContainer) {
        container[Columns.id] = id
        container[Columns.slug] = slug
        container[Columns.title] = title
        container[Columns.subtitle] = subtitle
        container[Columns.description] = description
        container[Columns.type] = type.rawValue
        container[Columns.readingLevel] = readingLevel.rawValue
        container[Columns.isPrebuilt] = isPrebuilt
        container[Columns.estimatedMinutes] = estimatedMinutes
        container[Columns.createdAt] = createdAt
        container[Columns.updatedAt] = updatedAt
        container[Columns.userId] = userId
        container[Columns.isPublic] = isPublic
        container[Columns.generationMode] = generationMode.rawValue
        container[Columns.modelId] = modelId
        container[Columns.promptVersion] = promptVersion
        container[Columns.schemaVersion] = schemaVersion
        container[Columns.generatedAt] = generatedAt

        // Encode JSON arrays using nonisolated helpers
        container[Columns.verseAnchors] = VerseRange.arrayToJSON(verseAnchors) ?? "[]"

        if let data = try? JSONEncoder().encode(sourcePassageIds),
           let json = String(data: data, encoding: .utf8) {
            container[Columns.sourcePassageIds] = json
        } else {
            container[Columns.sourcePassageIds] = "[]"
        }
    }
}

